// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: module_admin.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createModuleAdmin = `-- name: CreateModuleAdmin :one
INSERT INTO module_admins (
    module_id,
    user_id,
    super_admin,
    approved,
    motivational_letter,
    allowed_entity_types,
    allowed_menu
) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING module_id, user_id, created_at, super_admin, approved, motivational_letter, allowed_entity_types, allowed_menu
`

type CreateModuleAdminParams struct {
	ModuleID           int32        `json:"module_id"`
	UserID             int32        `json:"user_id"`
	SuperAdmin         bool         `json:"super_admin"`
	Approved           int32        `json:"approved"`
	MotivationalLetter string       `json:"motivational_letter"`
	AllowedEntityTypes []EntityType `json:"allowed_entity_types"`
	AllowedMenu        bool         `json:"allowed_menu"`
}

func (q *Queries) CreateModuleAdmin(ctx context.Context, arg CreateModuleAdminParams) (ModuleAdmin, error) {
	row := q.db.QueryRowContext(ctx, createModuleAdmin,
		arg.ModuleID,
		arg.UserID,
		arg.SuperAdmin,
		arg.Approved,
		arg.MotivationalLetter,
		pq.Array(arg.AllowedEntityTypes),
		arg.AllowedMenu,
	)
	var i ModuleAdmin
	err := row.Scan(
		&i.ModuleID,
		&i.UserID,
		&i.CreatedAt,
		&i.SuperAdmin,
		&i.Approved,
		&i.MotivationalLetter,
		pq.Array(&i.AllowedEntityTypes),
		&i.AllowedMenu,
	)
	return i, err
}

const deleteModuleAdmin = `-- name: DeleteModuleAdmin :exec
DELETE FROM module_admins WHERE module_id = $1 AND user_id = $2
`

type DeleteModuleAdminParams struct {
	ModuleID int32 `json:"module_id"`
	UserID   int32 `json:"user_id"`
}

func (q *Queries) DeleteModuleAdmin(ctx context.Context, arg DeleteModuleAdminParams) error {
	_, err := q.db.ExecContext(ctx, deleteModuleAdmin, arg.ModuleID, arg.UserID)
	return err
}

const getEntityModuleAdmin = `-- name: GetEntityModuleAdmin :one
SELECT
    vma.id, vma.module_type, vma.menu_id, vma.header_img_id, vma.thumbnail_img_id, vma.avatar_img_id, vma.world_id, vma.system_id, vma.character_id, vma.quest_id, vma.description_post_id, vma.user_id, vma.approved, vma.super_admin, vma.allowed_entity_types, vma.allowed_menu
FROM
    entities e
    JOIN view_module_admins vma ON e.module_id = vma.id
WHERE
    e.id = $1 AND
    vma.user_id = $2 AND
    (e.type = ANY(vma.allowed_entity_types) OR vma.super_admin = true)
`

type GetEntityModuleAdminParams struct {
	EntityID int32 `json:"entity_id"`
	UserID   int32 `json:"user_id"`
}

func (q *Queries) GetEntityModuleAdmin(ctx context.Context, arg GetEntityModuleAdminParams) (ViewModuleAdmin, error) {
	row := q.db.QueryRowContext(ctx, getEntityModuleAdmin, arg.EntityID, arg.UserID)
	var i ViewModuleAdmin
	err := row.Scan(
		&i.ID,
		&i.ModuleType,
		&i.MenuID,
		&i.HeaderImgID,
		&i.ThumbnailImgID,
		&i.AvatarImgID,
		&i.WorldID,
		&i.SystemID,
		&i.CharacterID,
		&i.QuestID,
		&i.DescriptionPostID,
		&i.UserID,
		&i.Approved,
		&i.SuperAdmin,
		pq.Array(&i.AllowedEntityTypes),
		&i.AllowedMenu,
	)
	return i, err
}

const getModuleAdmin = `-- name: GetModuleAdmin :one
SELECT id, module_type, menu_id, header_img_id, thumbnail_img_id, avatar_img_id, world_id, system_id, character_id, quest_id, description_post_id, user_id, approved, super_admin, allowed_entity_types, allowed_menu FROM view_module_admins WHERE user_id = $1 AND id = $2
`

type GetModuleAdminParams struct {
	UserID   int32 `json:"user_id"`
	ModuleID int32 `json:"module_id"`
}

func (q *Queries) GetModuleAdmin(ctx context.Context, arg GetModuleAdminParams) (ViewModuleAdmin, error) {
	row := q.db.QueryRowContext(ctx, getModuleAdmin, arg.UserID, arg.ModuleID)
	var i ViewModuleAdmin
	err := row.Scan(
		&i.ID,
		&i.ModuleType,
		&i.MenuID,
		&i.HeaderImgID,
		&i.ThumbnailImgID,
		&i.AvatarImgID,
		&i.WorldID,
		&i.SystemID,
		&i.CharacterID,
		&i.QuestID,
		&i.DescriptionPostID,
		&i.UserID,
		&i.Approved,
		&i.SuperAdmin,
		pq.Array(&i.AllowedEntityTypes),
		&i.AllowedMenu,
	)
	return i, err
}

const getModuleAdminByMenuId = `-- name: GetModuleAdminByMenuId :one
SELECT id, module_type, menu_id, header_img_id, thumbnail_img_id, avatar_img_id, world_id, system_id, character_id, quest_id, description_post_id, user_id, approved, super_admin, allowed_entity_types, allowed_menu FROM view_module_admins WHERE user_id = $1 AND menu_id = $2
`

type GetModuleAdminByMenuIdParams struct {
	UserID int32 `json:"user_id"`
	MenuID int32 `json:"menu_id"`
}

func (q *Queries) GetModuleAdminByMenuId(ctx context.Context, arg GetModuleAdminByMenuIdParams) (ViewModuleAdmin, error) {
	row := q.db.QueryRowContext(ctx, getModuleAdminByMenuId, arg.UserID, arg.MenuID)
	var i ViewModuleAdmin
	err := row.Scan(
		&i.ID,
		&i.ModuleType,
		&i.MenuID,
		&i.HeaderImgID,
		&i.ThumbnailImgID,
		&i.AvatarImgID,
		&i.WorldID,
		&i.SystemID,
		&i.CharacterID,
		&i.QuestID,
		&i.DescriptionPostID,
		&i.UserID,
		&i.Approved,
		&i.SuperAdmin,
		pq.Array(&i.AllowedEntityTypes),
		&i.AllowedMenu,
	)
	return i, err
}

const getModuleAdmins = `-- name: GetModuleAdmins :many
SELECT
    vu.id, vu.username, vu.hashed_password, vu.email, vu.img_id, vu.password_changed_at, vu.created_at, vu.is_email_verified, vu.introduction_post_id, vu.avatar_image_id, vu.avatar_image_url, vu.avatar_image_guid, vu.introduction_post_deleted_at,
    ma.module_id           as module_id,
    ma.created_at          as module_admin_created_at,
    ma.super_admin         as module_admin_super_admin,
    ma.approved            as module_admin_approved,
    ma.motivational_letter as module_admin_motivational_letter,
    ma.allowed_entity_types as module_admin_allowed_entity_types,
    ma.allowed_menu        as module_admin_allowed_menu
FROM
    view_users vu
    JOIN module_admins ma on ma.user_id = vu.id
WHERE
    ma.module_id = $1
`

type GetModuleAdminsRow struct {
	ID                            int32          `json:"id"`
	Username                      string         `json:"username"`
	HashedPassword                string         `json:"hashed_password"`
	Email                         string         `json:"email"`
	ImgID                         sql.NullInt32  `json:"img_id"`
	PasswordChangedAt             time.Time      `json:"password_changed_at"`
	CreatedAt                     time.Time      `json:"created_at"`
	IsEmailVerified               bool           `json:"is_email_verified"`
	IntroductionPostID            sql.NullInt32  `json:"introduction_post_id"`
	AvatarImageID                 sql.NullInt32  `json:"avatar_image_id"`
	AvatarImageUrl                sql.NullString `json:"avatar_image_url"`
	AvatarImageGuid               uuid.NullUUID  `json:"avatar_image_guid"`
	IntroductionPostDeletedAt     sql.NullTime   `json:"introduction_post_deleted_at"`
	ModuleID                      int32          `json:"module_id"`
	ModuleAdminCreatedAt          time.Time      `json:"module_admin_created_at"`
	ModuleAdminSuperAdmin         bool           `json:"module_admin_super_admin"`
	ModuleAdminApproved           int32          `json:"module_admin_approved"`
	ModuleAdminMotivationalLetter string         `json:"module_admin_motivational_letter"`
	ModuleAdminAllowedEntityTypes []EntityType   `json:"module_admin_allowed_entity_types"`
	ModuleAdminAllowedMenu        bool           `json:"module_admin_allowed_menu"`
}

func (q *Queries) GetModuleAdmins(ctx context.Context, moduleID int32) ([]GetModuleAdminsRow, error) {
	rows, err := q.db.QueryContext(ctx, getModuleAdmins, moduleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetModuleAdminsRow{}
	for rows.Next() {
		var i GetModuleAdminsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.HashedPassword,
			&i.Email,
			&i.ImgID,
			&i.PasswordChangedAt,
			&i.CreatedAt,
			&i.IsEmailVerified,
			&i.IntroductionPostID,
			&i.AvatarImageID,
			&i.AvatarImageUrl,
			&i.AvatarImageGuid,
			&i.IntroductionPostDeletedAt,
			&i.ModuleID,
			&i.ModuleAdminCreatedAt,
			&i.ModuleAdminSuperAdmin,
			&i.ModuleAdminApproved,
			&i.ModuleAdminMotivationalLetter,
			pq.Array(&i.ModuleAdminAllowedEntityTypes),
			&i.ModuleAdminAllowedMenu,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModulesOfAdmin = `-- name: GetModulesOfAdmin :many
SELECT
    id, module_type, menu_id, header_img_id, thumbnail_img_id, avatar_img_id, world_id, system_id, character_id, quest_id, description_post_id, user_id, approved, super_admin, allowed_entity_types, allowed_menu
FROM
    view_module_admins
WHERE
    user_id = $1 AND approved = 1
`

func (q *Queries) GetModulesOfAdmin(ctx context.Context, userID int32) ([]ViewModuleAdmin, error) {
	rows, err := q.db.QueryContext(ctx, getModulesOfAdmin, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ViewModuleAdmin{}
	for rows.Next() {
		var i ViewModuleAdmin
		if err := rows.Scan(
			&i.ID,
			&i.ModuleType,
			&i.MenuID,
			&i.HeaderImgID,
			&i.ThumbnailImgID,
			&i.AvatarImgID,
			&i.WorldID,
			&i.SystemID,
			&i.CharacterID,
			&i.QuestID,
			&i.DescriptionPostID,
			&i.UserID,
			&i.Approved,
			&i.SuperAdmin,
			pq.Array(&i.AllowedEntityTypes),
			&i.AllowedMenu,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateModuleAdmin = `-- name: UpdateModuleAdmin :one
UPDATE module_admins
SET
    super_admin = COALESCE($1, super_admin),
    approved = COALESCE($2, approved),
    motivational_letter = COALESCE($3, motivational_letter),
    allowed_entity_types = CASE
        WHEN $4 = true
            THEN COALESCE($5, allowed_entity_types)
        ELSE allowed_entity_types END,
    allowed_menu = COALESCE($6, allowed_menu)
WHERE
    module_id = $7 AND user_id = $8
RETURNING module_id, user_id, created_at, super_admin, approved, motivational_letter, allowed_entity_types, allowed_menu
`

type UpdateModuleAdminParams struct {
	SuperAdmin                sql.NullBool   `json:"super_admin"`
	Approved                  sql.NullInt32  `json:"approved"`
	MotivationalLetter        sql.NullString `json:"motivational_letter"`
	AllowedEntityTypesPresent interface{}    `json:"allowed_entity_types_present"`
	AllowedEntityTypes        []EntityType   `json:"allowed_entity_types"`
	AllowedMenu               sql.NullBool   `json:"allowed_menu"`
	ModuleID                  int32          `json:"module_id"`
	UserID                    int32          `json:"user_id"`
}

func (q *Queries) UpdateModuleAdmin(ctx context.Context, arg UpdateModuleAdminParams) (ModuleAdmin, error) {
	row := q.db.QueryRowContext(ctx, updateModuleAdmin,
		arg.SuperAdmin,
		arg.Approved,
		arg.MotivationalLetter,
		arg.AllowedEntityTypesPresent,
		pq.Array(arg.AllowedEntityTypes),
		arg.AllowedMenu,
		arg.ModuleID,
		arg.UserID,
	)
	var i ModuleAdmin
	err := row.Scan(
		&i.ModuleID,
		&i.UserID,
		&i.CreatedAt,
		&i.SuperAdmin,
		&i.Approved,
		&i.MotivationalLetter,
		pq.Array(&i.AllowedEntityTypes),
		&i.AllowedMenu,
	)
	return i, err
}

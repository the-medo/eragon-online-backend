// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: quest.sql

package db

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const createQuest = `-- name: CreateQuest :one
INSERT INTO quests (
    name,
    short_description,
    world_id,
    system_id
) VALUES (
    $1, $2, $3, $4
) RETURNING id, name, public, created_at, short_description, world_id, system_id
`

type CreateQuestParams struct {
	Name             string        `json:"name"`
	ShortDescription string        `json:"short_description"`
	WorldID          sql.NullInt32 `json:"world_id"`
	SystemID         sql.NullInt32 `json:"system_id"`
}

func (q *Queries) CreateQuest(ctx context.Context, arg CreateQuestParams) (Quest, error) {
	row := q.db.QueryRowContext(ctx, createQuest,
		arg.Name,
		arg.ShortDescription,
		arg.WorldID,
		arg.SystemID,
	)
	var i Quest
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Public,
		&i.CreatedAt,
		&i.ShortDescription,
		&i.WorldID,
		&i.SystemID,
	)
	return i, err
}

const deleteQuest = `-- name: DeleteQuest :exec
DELETE FROM quests WHERE id = $1
`

func (q *Queries) DeleteQuest(ctx context.Context, questID int32) error {
	_, err := q.db.ExecContext(ctx, deleteQuest, questID)
	return err
}

const getQuestByID = `-- name: GetQuestByID :one
SELECT id, name, public, created_at, short_description, world_id, system_id FROM quests WHERE id = $1 LIMIT 1
`

func (q *Queries) GetQuestByID(ctx context.Context, questID int32) (Quest, error) {
	row := q.db.QueryRowContext(ctx, getQuestByID, questID)
	var i Quest
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Public,
		&i.CreatedAt,
		&i.ShortDescription,
		&i.WorldID,
		&i.SystemID,
	)
	return i, err
}

const getQuests = `-- name: GetQuests :many
SELECT id, name, public, created_at, short_description, world_id, system_id, module_id, menu_id, header_img_id, thumbnail_img_id, avatar_img_id, tags FROM get_quests($1::boolean, $2::integer[], $3::integer, $4::integer, $5::VARCHAR, 'DESC', $6, $7)
`

type GetQuestsParams struct {
	IsPublic   bool    `json:"is_public"`
	Tags       []int32 `json:"tags"`
	WorldID    int32   `json:"world_id"`
	SystemID   int32   `json:"system_id"`
	OrderBy    string  `json:"order_by"`
	PageLimit  int32   `json:"page_limit"`
	PageOffset int32   `json:"page_offset"`
}

func (q *Queries) GetQuests(ctx context.Context, arg GetQuestsParams) ([]ViewQuest, error) {
	rows, err := q.db.QueryContext(ctx, getQuests,
		arg.IsPublic,
		pq.Array(arg.Tags),
		arg.WorldID,
		arg.SystemID,
		arg.OrderBy,
		arg.PageLimit,
		arg.PageOffset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ViewQuest{}
	for rows.Next() {
		var i ViewQuest
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Public,
			&i.CreatedAt,
			&i.ShortDescription,
			&i.WorldID,
			&i.SystemID,
			&i.ModuleID,
			&i.MenuID,
			&i.HeaderImgID,
			&i.ThumbnailImgID,
			&i.AvatarImgID,
			pq.Array(&i.Tags),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestsByIDs = `-- name: GetQuestsByIDs :many
SELECT id, name, public, created_at, short_description, world_id, system_id FROM quests WHERE id = ANY($1::int[])
`

func (q *Queries) GetQuestsByIDs(ctx context.Context, questIds []int32) ([]Quest, error) {
	rows, err := q.db.QueryContext(ctx, getQuestsByIDs, pq.Array(questIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Quest{}
	for rows.Next() {
		var i Quest
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Public,
			&i.CreatedAt,
			&i.ShortDescription,
			&i.WorldID,
			&i.SystemID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestsCount = `-- name: GetQuestsCount :one
SELECT COUNT(*) FROM view_quests
WHERE ($1::boolean IS NULL OR public = $1) AND
    (array_length($2::integer[], 1) IS NULL OR tags @> $2::integer[])
`

type GetQuestsCountParams struct {
	IsPublic bool    `json:"is_public"`
	Tags     []int32 `json:"tags"`
}

func (q *Queries) GetQuestsCount(ctx context.Context, arg GetQuestsCountParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getQuestsCount, arg.IsPublic, pq.Array(arg.Tags))
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateQuest = `-- name: UpdateQuest :one
UPDATE quests
SET
    name = COALESCE($1, name),
    short_description = COALESCE($2, short_description),
    public = COALESCE($3, public),
    world_id = COALESCE($4, world_id),
    system_id = COALESCE($5, system_id)
WHERE
    id = $6
    RETURNING id, name, public, created_at, short_description, world_id, system_id
`

type UpdateQuestParams struct {
	Name             sql.NullString `json:"name"`
	ShortDescription sql.NullString `json:"short_description"`
	Public           sql.NullBool   `json:"public"`
	WorldID          sql.NullInt32  `json:"world_id"`
	SystemID         sql.NullInt32  `json:"system_id"`
	QuestID          int32          `json:"quest_id"`
}

func (q *Queries) UpdateQuest(ctx context.Context, arg UpdateQuestParams) (Quest, error) {
	row := q.db.QueryRowContext(ctx, updateQuest,
		arg.Name,
		arg.ShortDescription,
		arg.Public,
		arg.WorldID,
		arg.SystemID,
		arg.QuestID,
	)
	var i Quest
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Public,
		&i.CreatedAt,
		&i.ShortDescription,
		&i.WorldID,
		&i.SystemID,
	)
	return i, err
}

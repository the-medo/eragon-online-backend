-- Generated by migrator v1.0 at 2024-11-18 18:43:18.421956 +0100 CET m=+0.018232001

-- Source file: db/migration/objects/000100_get_recursive_entities/000014_get_recursive_entities.sql

CREATE OR REPLACE FUNCTION get_recursive_entities(_main_entity_group_id INT)
    RETURNS SETOF entity_group_content AS $$
BEGIN
    RETURN QUERY
        WITH RECURSIVE entity_recursive AS (
            SELECT
                egc.id,
                egc.entity_group_id,
                egc.position,
                egc.content_entity_id,
                egc.content_entity_group_id
            FROM
                entity_group_content egc
            WHERE
                egc.entity_group_id = _main_entity_group_id

            UNION ALL

            SELECT
                child_egc.id,
                child_egc.entity_group_id,
                child_egc.position,
                child_egc.content_entity_id,
                child_egc.content_entity_group_id
            FROM
                entity_recursive er
                JOIN entity_group_content child_egc ON er.content_entity_group_id = child_egc.entity_group_id
            WHERE
                child_egc.content_entity_id IS NOT NULL OR child_egc.content_entity_group_id IS NOT NULL
        )
        SELECT * FROM entity_recursive;
END;
$$ LANGUAGE plpgsql;


-- Source file: db/migration/objects/000200_view_menus/000012_view_menus.sql

CREATE VIEW view_menus AS
SELECT
    m.*,
    i.url as header_image_url
FROM
    menus m
    LEFT JOIN images i ON m.menu_header_img_id = i.id
;

-- Source file: db/migration/objects/000300_view_module_admins/000020_view_module_admins.sql

CREATE VIEW view_module_admins AS
SELECT
    m.*,
    ma.user_id,
    ma.approved,
    ma.super_admin,
    ma.allowed_entity_types,
    ma.allowed_menu
FROM
    modules m
        JOIN module_admins ma ON ma.module_id = m.id
;

-- Source file: db/migration/objects/000400_view_module_type_tags_available/000018_view_module_type_tags_available.sql

CREATE VIEW view_module_type_tags_available AS
SELECT
    mtta.*,
    cast(COUNT(mt.module_id) as integer) as count
FROM
    module_type_tags_available mtta
        LEFT JOIN module_tags mt ON mt.tag_id = mtta.id
GROUP BY
    mtta.id
;

-- Source file: db/migration/objects/000500_view_users/000011_view_users.sql

CREATE VIEW view_users AS
SELECT
    u.*,
    i.id as avatar_image_id,
    i.url as avatar_image_url,
    i.img_guid as avatar_image_guid,
    p.deleted_at as introduction_post_deleted_at
FROM
    users AS u
    LEFT JOIN images i ON u.img_id = i.id
    LEFT JOIN posts p ON u.introduction_post_id = p.id
;

-- Source file: db/migration/objects/000600_view_entities/000030_view_entities.sql

CREATE VIEW view_entities AS
SELECT
    e.*,
    m.module_type as module_type,
    CAST(CASE m.module_type
         WHEN 'world' THEN m.world_id
         WHEN 'quest' THEN m.quest_id
         WHEN 'character' THEN m.character_id
         WHEN 'system' THEN m.system_id
    END as integer) as module_type_id,
    tags.tags as tags
FROM
    entities e
    LEFT JOIN modules m ON e.module_id = m.id
    LEFT JOIN (
        SELECT
            et.entity_id,
            CAST(COALESCE(array_agg(tag_available.id) FILTER (WHERE tag_available.id IS NOT NULL), ARRAY[]::integer[]) as integer[]) AS tags
        FROM
            entity_tags et
            LEFT JOIN module_entity_tags_available tag_available ON tag_available.id = et.tag_id
        GROUP BY et.entity_id
    ) tags ON tags.entity_id = e.id
;

-- Source file: db/migration/objects/000700_view_locations/000019_view_locations.sql

CREATE VIEW view_locations AS
SELECT
    l.*,
    i.url as thumbnail_image_url,
    p.title as post_title,
    e.id as entity_id,
    e.module_id as module_id,
    e.module_type as module_type,
    e.module_type_id as module_type_id,
    e.tags as tags
FROM
    locations l
    JOIN view_entities e ON e.location_id = l.id
    LEFT JOIN images i ON l.thumbnail_image_id = i.id
    LEFT JOIN posts p ON l.post_id = p.id
;

-- Source file: db/migration/objects/000800_view_images/000019_view_images.sql

CREATE VIEW view_images AS
SELECT
    i.*,
    e.id as entity_id,
    e.module_id as module_id,
    e.module_type as module_type,
    e.module_type_id as module_type_id,
    e.tags as tags
FROM
    images i
    LEFT JOIN view_entities e ON e.image_id = i.id
;

-- Source file: db/migration/objects/000900_view_maps/000027_view_maps.sql

CREATE VIEW view_maps AS
SELECT
    m.*,
    ml.image_id as base_layer_image_id,
    i.url as thumbnail_image_url,
    e.id as entity_id,
    e.module_id as module_id,
    e.module_type as module_type,
    e.module_type_id as module_type_id,
    e.tags as tags
FROM
    maps m
    JOIN map_layers ml ON ml.map_id = m.id AND ml.position = 1
    LEFT JOIN images i ON m.thumbnail_image_id = i.id
    LEFT JOIN view_entities e ON e.map_id = m.id
;

-- Source file: db/migration/objects/001000_view_posts/000021_view_posts.sql

CREATE VIEW view_posts AS
SELECT
    p.*,
    i.url as thumbnail_img_url,
    e.id as entity_id,
    e.module_id as module_id,
    e.module_type as module_type,
    e.module_type_id as module_type_id,
    e.tags as tags
FROM
    posts p
    LEFT JOIN images i ON p.thumbnail_img_id = i.id
    LEFT JOIN view_entities e ON e.post_id = p.id
;

-- Source file: db/migration/objects/001100_view_map_layers/000013_view_map_layers.sql

CREATE VIEW view_map_layers AS
SELECT
    ml.*,
    i.url as image_url
FROM
    map_layers ml
    LEFT JOIN images i ON ml.image_id = i.id
;

-- Source file: db/migration/objects/001200_view_map_pins/000013_view_map_pins.sql

CREATE VIEW view_map_pins AS
SELECT
    mp.*,
    l.name as location_name,
    l.post_id as location_post_id,
    l.description as location_description,
    l.thumbnail_image_id as location_thumbnail_image_id,
    i.url as location_thumbnail_image_url
FROM
    map_pins mp
    LEFT JOIN locations l ON mp.location_id = l.id
    LEFT JOIN images i ON l.thumbnail_image_id = i.id
;

-- Source file: db/migration/objects/001300_view_connection_posts/000023_view_connection_posts.sql

CREATE VIEW view_connections_posts AS
SELECT
    e.module_id as module_id,
    l.post_id as post_id,
    'locations.id' as table_column,
    l.id as table_column_value
FROM
    entities e
    JOIN locations l ON l.post_id = e.post_id
WHERE l.post_id IS NOT NULL

UNION ALL

SELECT
    m.id,
    mi.description_post_id,
    'menu_items.description_post_id',
    mi.id
FROM
    modules m
    JOIN menu_items mi ON mi.menu_id = m.menu_id
WHERE mi.description_post_id IS NOT NULL

UNION ALL

SELECT
    m.id,
    description_post_id,
    'modules.id',
    m.id
FROM
    modules m

UNION ALL

SELECT
    m.id,
    e.post_id,
    'entities.id',
    e.id
FROM
    modules m
    JOIN menu_items mi ON mi.menu_id = m.menu_id
    JOIN get_recursive_entities(mi.entity_group_id) re ON 1 = 1
    JOIN entities e ON e.id = re.content_entity_id
WHERE e.post_id IS NOT NULL
;

-- Source file: db/migration/objects/001400_view_modules/000030_view_modules.sql

CREATE VIEW view_modules AS
SELECT m.id as id,
       m.world_id as world_id,
       m.system_id as system_id,
       m.character_id as character_id,
       m.quest_id as quest_id,
       m.module_type as module_type,
       m.menu_id as menu_id,
       m.header_img_id as header_img_id,
       m.thumbnail_img_id as thumbnail_img_id,
       m.avatar_img_id as avatar_img_id,
       m.description_post_id as description_post_id,
       CAST(COALESCE(array_agg(tags.tag_id) FILTER (WHERE tags.tag_id IS NOT NULL), ARRAY[]::integer[]) as integer[]) AS tags
FROM
    modules m
        LEFT JOIN module_tags tags ON tags.module_id = m.id
GROUP BY m.id
;

-- Source file: db/migration/objects/001500_view_worlds/000023_view_worlds.sql

CREATE VIEW view_worlds AS
SELECT
    w.*,
    vm.id as module_id,
    vm.menu_id,
    vm.header_img_id,
    vm.thumbnail_img_id,
    vm.avatar_img_id,
    vm.tags
FROM
    worlds w
    JOIN view_modules vm ON w.id = vm.world_id
;

-- Source file: db/migration/objects/001600_get_worlds/000022_get_worlds.sql

CREATE OR REPLACE FUNCTION get_worlds(_is_public boolean, _tags integer[], _order_by varchar, _order_direction varchar, _limit int, _offset int)
    RETURNS SETOF view_worlds AS
$func$
DECLARE
    _limit_string VARCHAR;
BEGIN
    IF _order_by IS NULL THEN
        _order_by := 'created_at';
    END IF;

    IF _order_direction IS NULL OR (_order_direction <> 'ASC' AND _order_direction <> 'DESC') THEN
        _order_direction := 'DESC';
    END IF;

    _limit_string := '';
    IF _limit > 0 THEN
        _limit_string := 'LIMIT ' || _limit;
    END IF;

    RETURN QUERY EXECUTE format('
        SELECT * FROM view_worlds
        WHERE
            ($1 IS NULL OR public = $1) AND
            (array_length($2, 1) IS NULL OR tags @> $2)
        ORDER BY %I ' || _order_direction || ' ' || _limit_string || '
        OFFSET $3', _order_by)
        USING _is_public, _tags, _offset;
END
$func$  LANGUAGE plpgsql;

-- Source file: db/migration/objects/001700_get_posts/000022_get_posts.sql

CREATE OR REPLACE FUNCTION get_posts(_is_private boolean, _is_draft boolean, _tags integer[], _user_id integer, _module_id integer, _module_type module_type, _order_by varchar, _order_direction varchar, _limit int, _offset int)
    RETURNS SETOF view_posts AS
$func$
DECLARE
    _limit_string VARCHAR;
BEGIN
    IF _order_by IS NULL THEN
        _order_by := 'created_at';
    END IF;

    IF _order_direction IS NULL OR (_order_direction <> 'ASC' AND _order_direction <> 'DESC') THEN
        _order_direction := 'DESC';
    END IF;

    _limit_string := '';
    IF _limit > 0 THEN
        _limit_string := 'LIMIT ' || _limit;
    END IF;

    RETURN QUERY EXECUTE format('
        SELECT * FROM view_posts
        WHERE
            ($1 IS NULL OR is_private = $1) AND
            ($2 IS NULL OR is_draft = $2) AND
            ($5 IS NULL OR user_id = $5) AND
            ($6 IS NULL OR module_id = $6) AND
            ($7 IS NULL OR module_type = $7) AND
            deleted_at IS NULL AND
            (array_length($3, 1) IS NULL OR tags @> $3)
        ORDER BY %I ' || _order_direction || ' ' || _limit_string || '
        OFFSET $4 ', _order_by)
        USING _is_private, _is_draft, _tags, _offset, _user_id, _module_id, _module_type;
END
$func$  LANGUAGE plpgsql;

-- Source file: db/migration/objects/001800_get_images/000022_get_images.sql

CREATE OR REPLACE FUNCTION get_images(_tags integer[], _width integer, _height integer, _user_id integer, _module_id integer, _module_type module_type, _order_by varchar, _order_direction varchar, _limit int, _offset int)
    RETURNS SETOF view_images AS
$func$
DECLARE
    _limit_string VARCHAR;
BEGIN
    IF _order_by IS NULL THEN
        _order_by := 'created_at';
    END IF;

    IF _order_direction IS NULL OR (_order_direction <> 'ASC' AND _order_direction <> 'DESC') THEN
        _order_direction := 'DESC';
    END IF;

    _limit_string := '';
    IF _limit > 0 THEN
        _limit_string := 'LIMIT ' || _limit;
    END IF;

    RETURN QUERY EXECUTE format('
        SELECT * FROM view_images
        WHERE
            ($1 IS NULL OR width = $1) AND
            ($2 IS NULL OR height = $2) AND
            ($5 IS NULL OR user_id = $5) AND
            ($6 IS NULL OR module_id = $6) AND
            ($7 IS NULL OR module_type = $7) AND
            (array_length($3, 1) IS NULL OR tags @> $3)
        ORDER BY %I ' || _order_direction || ' ' || _limit_string || '
        OFFSET $4 ', _order_by)
        USING _width, _height, _tags, _offset, _user_id, _module_id, _module_type;
END
$func$  LANGUAGE plpgsql;

-- Source file: db/migration/objects/001900_update_map_layer_is_main/000028_update_map_layer_is_main.sql

-- no longer valid - is_main column deleted

-- Source file: db/migration/objects/002000_move_menu_item/000012_move_menu_item.sql

CREATE OR REPLACE PROCEDURE move_menu_item(p_id INT, p_target_position INT)
    LANGUAGE plpgsql AS $$
DECLARE
    v_old_position INT;
    v_menu_id INT;
    v_max_position INT;
BEGIN
    -- Get the current position and menu_id of the menu item
    SELECT "position", "menu_id" INTO v_old_position, v_menu_id
    FROM "menu_items"
    WHERE "id" = p_id;

    -- Get the maximum position within the menu
    SELECT MAX("position") INTO v_max_position
    FROM "menu_items"
    WHERE "menu_id" = v_menu_id;

    -- Check if the target position is valid
    IF p_target_position < 1 OR p_target_position > v_max_position THEN
        RAISE EXCEPTION 'Invalid target position';
    END IF;

    -- Update positions based on the move direction
    IF v_old_position < p_target_position THEN
        -- Move down
        UPDATE "menu_items"
        SET "position" = "position" - 1
        WHERE "menu_id" = v_menu_id
          AND "position" BETWEEN v_old_position + 1 AND p_target_position;

    ELSIF v_old_position > p_target_position THEN
        -- Move up
        UPDATE "menu_items"
        SET "position" = "position" + 1
        WHERE "menu_id" = v_menu_id
          AND "position" BETWEEN p_target_position AND v_old_position - 1;
    END IF;

    -- Set the new position of the menu item
    UPDATE "menu_items"
    SET "position" = p_target_position
    WHERE "id" = p_id;

END;
$$;

-- Source file: db/migration/objects/002100_move_group_up/000012_move_group_up.sql

CREATE OR REPLACE PROCEDURE move_group_up(p_id INT)
    LANGUAGE plpgsql AS $$
DECLARE
    v_menu_id INT;
    v_target_group_start INT;
    v_target_group_end INT;
    v_prev_group_start INT;
    v_prev_group_end INT;
    v_target_group_size INT;
    v_prev_group_size INT;
    v_temp_offset INT := 1000;
BEGIN
    -- Get the menu_id and the position of the main item of the target group
    SELECT "menu_id", "position" INTO v_menu_id, v_target_group_start
    FROM "menu_items"
    WHERE "id" = p_id;

    -- Find the end position of the target group
    SELECT
        COALESCE(
                MIN("position"),
                (SELECT MAX(position) + 1 FROM menu_items WHERE menu_id = 2)
        ) - 1 INTO v_target_group_end
    FROM "menu_items"
    WHERE "menu_id" = v_menu_id
      AND "position" > v_target_group_start
      AND "is_main" = true;

    -- Find the end position of the previous group
    SELECT MAX("position") INTO v_prev_group_end
    FROM "menu_items"
    WHERE "menu_id" = v_menu_id
      AND "position" < v_target_group_start;

    -- If there's no previous group, exit the procedure
    IF v_prev_group_end IS NULL THEN
        RAISE NOTICE 'This group is already at the top';
        RETURN;
    END IF;

    -- Find the start position of the previous group
    SELECT COALESCE(MAX("position"), 0) INTO v_prev_group_start
    FROM "menu_items"
    WHERE "menu_id" = v_menu_id
      AND "position" <= v_prev_group_end
      AND "is_main" = true;


    -- If there's no group for previous item, exit the procedure
    IF v_prev_group_start = 0 THEN
        RAISE NOTICE 'Previous item has no group';
        RETURN;
    END IF;

    -- Calculate the size of both groups
    v_target_group_size := v_target_group_end - v_target_group_start + 1;
    v_prev_group_size := v_prev_group_end - v_prev_group_start + 1;

    -- Temporarily move the target group out of the way
    UPDATE "menu_items"
    SET "position" = "position" + v_temp_offset
    WHERE "menu_id" = v_menu_id
      AND "position" BETWEEN v_target_group_start AND v_target_group_end;

    -- Move the previous group down by the size of the target group
    UPDATE "menu_items"
    SET "position" = "position" + v_target_group_size
    WHERE "menu_id" = v_menu_id
      AND "position" BETWEEN v_prev_group_start AND v_prev_group_end;

    -- Move the target group up by the size of the previous group
    UPDATE "menu_items"
    SET "position" = "position" - v_prev_group_size - v_temp_offset
    WHERE "menu_id" = v_menu_id
      AND "position" BETWEEN v_target_group_start + v_temp_offset AND v_target_group_end + v_temp_offset;

END;
$$;


-- Source file: db/migration/objects/002200_move_entity_group_content/000025_move_entity_group_content.sql

CREATE OR REPLACE PROCEDURE move_entity_group_content(p_id INT, p_new_entity_group_id INT, p_new_position INT)
    LANGUAGE plpgsql AS $$
DECLARE
    v_old_position INT;
    v_old_entity_group_id INT;
    v_old_content_entity_group_id INT;
    v_new_max_position INT;
    v_recursion_check INT;
BEGIN
    -- Get the current position and entity_group_id of the content
    SELECT "position", "entity_group_id", "content_entity_group_id" INTO v_old_position, v_old_entity_group_id, v_old_content_entity_group_id
    FROM "entity_group_content"
    WHERE "id" = p_id;

    -- in case of empty entity group, we move inside of the same group
    IF p_new_entity_group_id IS NULL THEN
        p_new_entity_group_id := v_old_entity_group_id;
    end if;

    -- Check for recursive groups
    IF v_old_content_entity_group_id IS NOT NULL THEN
        -- we need to check, if the new group is not inside of the actual moved group - if that was the case, groups would be recursive and we can not have that
        SELECT COUNT(*) INTO v_recursion_check FROM get_recursive_entities(v_old_content_entity_group_id ) WHERE content_entity_group_id = p_new_entity_group_id;

        IF v_recursion_check > 0 OR p_new_entity_group_id = v_old_content_entity_group_id THEN
            RAISE EXCEPTION 'Recursion check failed';
        END IF;
    END IF;

    IF p_new_entity_group_id != v_old_entity_group_id THEN

        -- Get the maximum position within the new group
        SELECT MAX("position") + 1 INTO v_new_max_position
        FROM "entity_group_content"
        WHERE "entity_group_id" = p_new_entity_group_id;

        IF p_new_position IS NULL THEN
            p_new_position := v_new_max_position;
        end if;

        -- Check if the target position is valid
        IF p_new_position < 1 OR p_new_position > v_new_max_position THEN
            RAISE EXCEPTION 'Invalid target position';
        END IF;

        -- Move down old entity group contents
        UPDATE "entity_group_content"
        SET "position" = "position" - 1
        WHERE "entity_group_id" = v_old_entity_group_id
          AND "position" >= v_old_position;

        -- Move up new entity group contents
        UPDATE "entity_group_content"
        SET "position" = "position" + 1
        WHERE "entity_group_id" = p_new_entity_group_id
          AND "position" >= p_new_position;

    ELSE -- group is moved inside of the same group

        -- Move up new entity group contents
        UPDATE "entity_group_content"
        SET "position" = "position" + CASE WHEN p_new_position > v_old_position THEN -1 ELSE 1 END
        WHERE "entity_group_id" = v_old_entity_group_id
          AND "position" BETWEEN LEAST(p_new_position, v_old_position) AND GREATEST(p_new_position, v_old_position);

    END IF;

    -- Set the new position and parent of the group content
    UPDATE "entity_group_content"
    SET "position" = p_new_position, "entity_group_id" = p_new_entity_group_id
    WHERE "id" = p_id;

END;
$$;

-- Source file: db/migration/objects/002300_get_menu_id_of_entity_group/000014_get_menu_id_of_entity_group.sql

create function get_menu_id_of_entity_group(_entity_group_id integer)
    returns TABLE(menu_id integer, entity_group_id integer)
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        WITH RECURSIVE entity_group_hierarchy AS (
            SELECT
                meg.menu_id,
                meg.entity_group_id
            FROM
                menu_items meg
            UNION ALL
            SELECT
                egh.menu_id,
                egc.content_entity_group_id
            FROM
                entity_group_hierarchy egh
                    JOIN entity_group_content egc ON egh.entity_group_id = egc.entity_group_id
            WHERE
                egc.content_entity_group_id IS NOT NULL
        )
        SELECT * FROM entity_group_hierarchy egh2 WHERE egh2.entity_group_id = _entity_group_id;
END;
$$;
alter function get_menu_id_of_entity_group(integer) owner to root;

-- Source file: db/migration/objects/002400_delete_entity_group/000025_delete_entity_group.sql

CREATE OR REPLACE PROCEDURE delete_entity_group(_entity_group_id integer, _delete_type delete_entity_group_content_action)
    LANGUAGE plpgsql AS $$
DECLARE
    egc RECORD;
    v_is_main_menu_item_group INT;
    v_entity_group_content_id INT;
    v_parent_entity_group_id INT;
    v_position_in_parent INT;
    v_children_count INT;
BEGIN

    SELECT COUNT(*) FROM menu_items WHERE entity_group_id = _entity_group_id INTO v_is_main_menu_item_group;
    SELECT id, entity_group_id, position FROM entity_group_content WHERE content_entity_group_id = _entity_group_id INTO v_entity_group_content_id, v_parent_entity_group_id, v_position_in_parent;

    SELECT COUNT(*) FROM entity_group_content WHERE entity_group_id = _entity_group_id INTO v_children_count;

    IF _delete_type = 'delete_children' THEN

        -- first, we delete contents of the entity group
        FOR egc IN (SELECT * FROM entity_group_content WHERE entity_group_id = _entity_group_id) LOOP
                CALL delete_entity_group_content(egc.id, _delete_type);
            END LOOP;


        IF v_entity_group_content_id IS NOT NULL THEN
            CALL delete_entity_group_content_and_move(v_entity_group_content_id);
        END IF;

    end if;

    IF _delete_type = 'move_children' THEN

        UPDATE entity_group_content SET position = position + v_children_count - 1 WHERE entity_group_id = v_parent_entity_group_id AND position > v_position_in_parent;

        UPDATE entity_group_content SET position = position + v_position_in_parent - 1, entity_group_id = v_parent_entity_group_id WHERE entity_group_id = _entity_group_id;


        DELETE FROM "entity_group_content" d WHERE d.id = v_entity_group_content_id;

    end if;

    -- then, we delete the entity group itself if it is not a main menu item group
    IF v_is_main_menu_item_group IS NOT NULL AND v_is_main_menu_item_group = 0 THEN
        DELETE FROM entity_groups WHERE id = _entity_group_id;
    END IF;
END;
$$;

-- Source file: db/migration/objects/002500_delete_menu_item/000014_delete_menu_item.sql

CREATE OR REPLACE PROCEDURE delete_menu_item(_menu_item_id INT)
    LANGUAGE plpgsql AS $$
DECLARE
    _entity_group_id INT;
    _menu_id INT;
    _position INT;
BEGIN
    -- Delete the menu item and get the entity_group_id
    WITH deleted_item AS (
        DELETE FROM "menu_items"
            WHERE id = _menu_item_id
            RETURNING entity_group_id, menu_id, position
    )
    SELECT entity_group_id, menu_id, position INTO _entity_group_id, _menu_id, _position FROM deleted_item;

    UPDATE "menu_items"
    SET "position" = "position" - 1
    WHERE "menu_id" = _menu_id AND "position" > _position;


    IF _entity_group_id IS NOT NULL THEN
        CALL delete_entity_group(_entity_group_id);
    END IF;
END;
$$;

-- Source file: db/migration/objects/002600_delete_entity_group_content_and_move/000014_delete_entity_group_content_and_move.sql

 CREATE OR REPLACE PROCEDURE delete_entity_group_content_and_move(_id integer)
    LANGUAGE plpgsql AS $$
BEGIN
    WITH deleted_entity_group_content AS (
        DELETE FROM "entity_group_content" d
            WHERE d.id = _id
            RETURNING *
    )
    UPDATE "entity_group_content"
    SET "position" = "position" - 1
    WHERE
        "entity_group_id" = (SELECT entity_group_id FROM deleted_entity_group_content)
      AND "position" > (SELECT position FROM deleted_entity_group_content);
END;
$$;

-- Source file: db/migration/objects/002700_delete_entity_group_content/000025_delete_entity_group_content.sql

CREATE OR REPLACE PROCEDURE delete_entity_group_content(_id integer, _delete_type delete_entity_group_content_action)
    LANGUAGE plpgsql AS $$
DECLARE
    v_content_entity_id INT;
    v_content_entity_group_id INT;
BEGIN
    SELECT content_entity_id, content_entity_group_id INTO v_content_entity_id, v_content_entity_group_id FROM entity_group_content WHERE id = _id;

    IF v_content_entity_id IS NOT NULL THEN
--         DELETE FROM entities WHERE id = v_content_entity_id;
        CALL delete_entity_group_content_and_move(_id);
    END IF;

    IF v_content_entity_group_id IS NOT NULL THEN
        CALL delete_entity_group(v_content_entity_group_id, _delete_type);
    END IF;

END;
$$;

-- Source file: db/migration/objects/002800_delete_location/000016_delete_location.sql

CREATE OR REPLACE PROCEDURE delete_location(p_location_id INT)
    LANGUAGE plpgsql
AS $$
DECLARE
    _egc RECORD;
BEGIN
    -- remove location from associated map pins
    UPDATE map_pins SET location_id = NULL WHERE location_id = p_location_id;

    -- Delete all the entities of the location
    FOR _egc IN (
        SELECT
            content.id as entity_group_content_id,
            e.id as entity_id
        FROM
            entity_group_content content
                JOIN entities e ON e.id = content.content_entity_id
        WHERE
            e.location_id = p_location_id
    ) LOOP
            CALL delete_entity_group_content(_egc.entity_group_content_id, _egc.entity_id, NULL);
        END LOOP;

    DELETE FROM entities WHERE location_id = p_location_id;

    DELETE FROM locations WHERE id = p_location_id;
END;
$$;

-- Source file: db/migration/objects/002900_delete_map/000016_delete_map.sql

CREATE OR REPLACE PROCEDURE delete_map(p_map_id INT)
    LANGUAGE plpgsql
AS $$
DECLARE
    _egc RECORD;
BEGIN
    DELETE FROM map_pins WHERE map_id = p_map_id;
    DELETE FROM map_layers WHERE map_id = p_map_id;
    DELETE FROM map_layers WHERE map_id = p_map_id;

    -- Delete all the entities of the location
    FOR _egc IN (
        SELECT
            content.id as entity_group_content_id,
            e.id as entity_id
        FROM
            entity_group_content content
                JOIN entities e ON e.id = content.content_entity_id
        WHERE
            e.map_id = p_map_id
    ) LOOP
            CALL delete_entity_group_content(_egc.entity_group_content_id, _egc.entity_id, NULL);
        END LOOP;

    DELETE FROM entities WHERE map_id = p_map_id;

    DELETE FROM maps WHERE id = p_map_id;
END;
$$;

-- Source file: db/migration/objects/003000_get_locations/000025_get_locations.sql

CREATE OR REPLACE FUNCTION get_locations(_tags integer[], _module_id integer, _module_type module_type, _order_by varchar, _order_direction varchar, _limit int, _offset int)
    RETURNS SETOF view_locations AS
$func$
DECLARE
    _limit_string VARCHAR;
BEGIN
    IF _order_by IS NULL THEN
        _order_by := 'id';
    END IF;

    IF _order_direction IS NULL OR (_order_direction <> 'ASC' AND _order_direction <> 'DESC') THEN
        _order_direction := 'DESC';
    END IF;

    _limit_string := '';
    IF _limit > 0 THEN
        _limit_string := 'LIMIT ' || _limit;
    END IF;

    RETURN QUERY EXECUTE format('
        SELECT * FROM view_locations
        WHERE
            ($3 IS NULL OR module_id = $3) AND
            ($4 IS NULL OR module_type = $4) AND
            (array_length($1, 1) IS NULL OR tags @> $1)
        ORDER BY %I ' || _order_direction || ' ' || _limit_string || '
        OFFSET $2 ', _order_by)
        USING _tags, _offset, _module_id, _module_type;
END
$func$  LANGUAGE plpgsql;

-- Source file: db/migration/objects/003100_get_maps/000025_get_maps.sql

CREATE OR REPLACE FUNCTION get_maps(_tags integer[], _module_id integer, _module_type module_type, _order_by varchar, _order_direction varchar, _limit int, _offset int)
    RETURNS SETOF view_maps AS
$func$
DECLARE
    _limit_string VARCHAR;
BEGIN
    IF _order_by IS NULL THEN
        _order_by := 'id';
    END IF;

    IF _order_direction IS NULL OR (_order_direction <> 'ASC' AND _order_direction <> 'DESC') THEN
        _order_direction := 'DESC';
    END IF;

    _limit_string := '';
    IF _limit > 0 THEN
        _limit_string := 'LIMIT ' || _limit;
    END IF;

    RETURN QUERY EXECUTE format('
        SELECT * FROM view_maps
        WHERE
            ($3 IS NULL OR module_id = $3) AND
            ($4 IS NULL OR module_type = $4) AND
            (array_length($1, 1) IS NULL OR tags @> $1)
        ORDER BY %I ' || _order_direction || ' ' || _limit_string || '
        OFFSET $2 ', _order_by)
        USING _tags, _offset, _module_id, _module_type;
END
$func$  LANGUAGE plpgsql;

-- Source file: db/migration/objects/003200_create_entity_group_content/000025_create_entity_group_content.sql

CREATE OR REPLACE FUNCTION create_entity_group_content(p_entity_group_id INT, p_content_entity_group_id INT, p_content_entity_id INT, p_new_position INT)
    RETURNS SETOF entity_group_content AS $$
DECLARE
    v_max_position INT;
    v_final_position INT;
BEGIN
    SELECT COALESCE(MAX("position"), 0) INTO v_max_position
    FROM "entity_group_content"
    WHERE "entity_group_id" = p_entity_group_id;

    -- If we didn't get new position as a parameter, we add it to the end
    IF p_new_position IS NULL THEN
        v_final_position = v_max_position + 1;
    ELSE
        -- Check if the target position is valid
        IF p_new_position < 1 OR p_new_position > v_max_position + 1 THEN
            RAISE EXCEPTION 'Invalid target position';
        END IF;

        v_final_position = p_new_position;

        -- Increase positions of entity group contents
        UPDATE "entity_group_content"
        SET "position" = "position" + 1
        WHERE "entity_group_id" = p_entity_group_id
          AND "position" >= v_final_position;
    END IF;

    RETURN QUERY INSERT INTO "entity_group_content" (entity_group_id, position, content_entity_id, content_entity_group_id)  VALUES
    (p_entity_group_id, v_final_position, p_content_entity_id, p_content_entity_group_id) RETURNING *;
END
$$ LANGUAGE plpgsql;

-- Source file: db/migration/objects/003300_move_map_layer/000028_move_map_layer.sql

CREATE OR REPLACE PROCEDURE move_map_layer(p_id INT, p_target_position INT)
    LANGUAGE plpgsql AS $$
DECLARE
    v_old_position INT;
    v_map_id INT;
    v_max_position INT;
BEGIN
    -- Get the current position and menu_id of the menu item
    SELECT "position", "map_id" INTO v_old_position, v_map_id
    FROM "map_layers"
    WHERE "id" = p_id;

    -- Get the maximum position within the menu
    SELECT MAX("position") INTO v_max_position
    FROM "map_layers"
    WHERE "map_id" = v_map_id;

    -- Check if the target position is valid
    IF p_target_position < 1 OR p_target_position > v_max_position THEN
        RAISE EXCEPTION 'Invalid target position';
    END IF;

    -- Update positions based on the move direction
    IF v_old_position < p_target_position THEN
        -- Move down
        UPDATE "map_layers"
        SET "position" = "position" - 1
        WHERE "map_id" = v_map_id
          AND "position" BETWEEN v_old_position + 1 AND p_target_position;

    ELSIF v_old_position > p_target_position THEN
        -- Move up
        UPDATE "map_layers"
        SET "position" = "position" + 1
        WHERE "map_id" = v_map_id
          AND "position" BETWEEN p_target_position AND v_old_position - 1;
    END IF;

    -- Set the new position of the menu item
    UPDATE "map_layers"
    SET "position" = p_target_position
    WHERE "id" = p_id;

END;
$$;

-- Source file: db/migration/objects/003400_view_systems/000030_view_systems.sql

CREATE VIEW view_systems AS
SELECT
    s.*,
    vm.id as module_id,
    vm.menu_id,
    vm.header_img_id,
    vm.thumbnail_img_id,
    vm.avatar_img_id,
    vm.tags
FROM
    systems s
    JOIN view_modules vm ON s.id = vm.system_id
;

-- Source file: db/migration/objects/003500_get_systems/000030_get_systems.sql

CREATE OR REPLACE FUNCTION get_systems(_is_public boolean, _tags integer[], _order_by varchar, _order_direction varchar, _limit int, _offset int)
    RETURNS SETOF view_systems AS
$func$
DECLARE
    _limit_string VARCHAR;
BEGIN
    IF _order_by IS NULL THEN
        _order_by := 'created_at';
    END IF;

    IF _order_direction IS NULL OR (_order_direction <> 'ASC' AND _order_direction <> 'DESC') THEN
        _order_direction := 'DESC';
    END IF;

    _limit_string := '';
    IF _limit > 0 THEN
        _limit_string := 'LIMIT ' || _limit;
    END IF;

    RETURN QUERY EXECUTE format('
        SELECT * FROM view_systems
        WHERE
            ($1 IS NULL OR public = $1) AND
            (array_length($2, 1) IS NULL OR tags @> $2)
        ORDER BY %I ' || _order_direction || ' ' || _limit_string || '
        OFFSET $3', _order_by)
        USING _is_public, _tags, _offset;
END
$func$  LANGUAGE plpgsql;

-- Source file: db/migration/objects/003600_view_characters/000030_view_characters.sql

CREATE VIEW view_characters AS
SELECT
    c.*,
    vm.id as module_id,
    vm.menu_id,
    vm.header_img_id,
    vm.thumbnail_img_id,
    vm.avatar_img_id,
    vm.tags
FROM
    characters c
    JOIN view_modules vm ON c.id = vm.character_id
;

-- Source file: db/migration/objects/003700_get_characters/000030_get_characters.sql

CREATE OR REPLACE FUNCTION get_characters(
    _is_public boolean,
    _tags integer[],
    _world_id int,
    _system_id int,
    _order_by varchar,
    _order_direction varchar,
    _limit int,
    _offset int
) RETURNS SETOF view_characters AS
$func$
DECLARE
    _limit_string VARCHAR;
BEGIN
    IF _order_by IS NULL THEN
        _order_by := 'created_at';
    END IF;

    IF _order_direction IS NULL OR (_order_direction <> 'ASC' AND _order_direction <> 'DESC') THEN
        _order_direction := 'DESC';
    END IF;

    _limit_string := '';
    IF _limit > 0 THEN
        _limit_string := 'LIMIT ' || _limit;
    END IF;

    RETURN QUERY EXECUTE format('
        SELECT * FROM view_characters
        WHERE
            ($1 IS NULL OR public = $1) AND
            (array_length($2, 1) IS NULL OR tags @> $2) AND
            ($3 IS NULL OR world_id = $3) AND
            ($4 IS NULL OR system_id = $4)
        ORDER BY %I %s %s
        OFFSET $5', _order_by, _order_direction, _limit_string)
        USING _is_public, _tags, _world_id, _system_id, _offset;
END
$func$  LANGUAGE plpgsql;

-- Source file: db/migration/objects/003800_view_quests/000031_view_quests.sql

CREATE VIEW view_quests AS
SELECT
    q.*,
    qs.status as status,
    qs.can_join as can_join,
    vm.id as module_id,
    vm.menu_id,
    vm.header_img_id,
    vm.thumbnail_img_id,
    vm.avatar_img_id,
    vm.tags
FROM
    quests q
    JOIN view_modules vm ON q.id = vm.quest_id
    JOIN quest_settings qs ON q.id = qs.quest_id
;

-- Source file: db/migration/objects/003900_get_quests/000030_get_quests.sql

CREATE OR REPLACE FUNCTION get_quests(
    _is_public boolean,
    _tags integer[],
    _world_id int,
    _system_id int,
    _order_by varchar,
    _order_direction varchar,
    _limit int,
    _offset int
) RETURNS SETOF view_quests AS
$func$
DECLARE
    _limit_string VARCHAR;
BEGIN
    IF _order_by IS NULL THEN
        _order_by := 'created_at';
    END IF;

    IF _order_direction IS NULL OR (_order_direction <> 'ASC' AND _order_direction <> 'DESC') THEN
        _order_direction := 'DESC';
    END IF;

    _limit_string := '';
    IF _limit > 0 THEN
        _limit_string := 'LIMIT ' || _limit;
    END IF;

RETURN QUERY EXECUTE format('
        SELECT * FROM view_quests
        WHERE
            ($1 IS NULL OR public = $1) AND
            (array_length($2, 1) IS NULL OR tags @> $2) AND
            ($3 IS NULL OR world_id = $3) AND
            ($4 IS NULL OR system_id = $4)
        ORDER BY %I %s %s
        OFFSET $5', _order_by, _order_direction, _limit_string)
    USING _is_public, _tags, _world_id, _system_id, _offset;
END
$func$  LANGUAGE plpgsql;

